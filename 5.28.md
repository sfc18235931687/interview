**网络基础部分**

**一、socket长连接是什么意思；**

在一个TCP连接上可以连续发送多个数据包，在TCP连接保持期间，如果没有数据包发送，

需要双方发检测包以维持此链接，一般需要自己做在线维持。

长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差

数据库的连接用长连接。如果用短连接频繁的通信会造成socket错误，

而且频繁的socket创建也是对资源的浪费



**二、*args,kwargs的作用是什么？如何使用**

*args和**kwargs通常使用在函数定义里，*

*args允许函数传入不定量个数的非关键字参数
**kwargs允许函数传入不定量个数的关键字参数



**三、python是怎么进行内存管理的？**

- 引用计数：python内部使用引用计数，来保持追踪内存中的对象，Python内部记录了对象有多少个引用，即引用计数，当对象被创建时就创建了一个引用计数，当对象不再需要时，这个对象的引用计数为0时，它被垃圾回收。
  引用计数加1的情况：
  对象被创建：x=4
  另外的别人被创建：y=x
  被作为参数传递给函数：foo(x)
  作为容器对象的一个元素：a=[1,x,'33']
  引用计数减少情况
  一个本地引用离开了它的作用域。比如上面的foo(x)函数结束时，x指向的对象引用减1。
  对象的别名被显式的销毁：del x ；或者del y
  对象的一个别名被赋值给其他对象：x=789
  对象从一个窗口对象中移除：myList.remove(x)
  窗口对象本身被销毁：del myList，或者窗口对象本身离开了作用域
- 垃圾回收
  当内存中有不再使用的部分时，垃圾收集器就会把他们清理掉。它会去检查那些引用计数为0的对象，然后清除其在内存的空间。当然除了引用计数为0的会被清除，还有一种情况也会被垃圾收集器清掉：当两个对象相互引用时，他们本身其他的引用已经为0了。
  垃圾回收机制还有一个循环垃圾回收器, 确保释放循环引用对象(a引用b, b引用a, 导致其引用计数永远不为0)。
- 内存池机制：在Python中，许多时候申请的内存都是小块的内存，这些小块内存在申请后，很快又会被释放，由于这些内存的申请并不是为了创建对象，所以并没有对象一级的内存池机制。这就意味着Python在运行期间会大量地执行malloc和free的操作，频繁地在用户态和核心态之间进行切换，这将严重影响Python的执行效率。为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。
  Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。
  Python中所有小于256个字节的对象都使用pymalloc实现的分配器，而大的对象则使用系统的 malloc。另外Python对象，如整数，浮点数和List，都有其独立的私有内存池，对象间不共享他们的内存池。也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数
  



**四、python中如何拷贝一个对象？（赋值，浅拷贝，深拷贝的区别）**

赋值（=），就是创建了对象的一个新的引用，修改其中任意一个变量都会影响到另一个。

浅拷贝：创建一个新的对象，但它包含的是对原始对象中包含项的引用（如果用引用的方式修改其中一个对象，另外一个也会修改改变）{1,完全切片方法；2，工厂函数，如list()；3，copy模块的copy()函数}

深拷贝：创建一个新的对象，并且递归的复制它所包含的对象（修改其中一个，另外一个不会改变）{copy模块的deep.deepcopy()函数}



**五、请解释一下cookie和session的关系，以及csrf的攻击和防范方法**

1.cookie保存在浏览器端，session保存在服务器端，但是为了区分不同的客户端，服务器会在浏览器中发送一个对应的sessionid保存到cookies中，下次浏览器请求服务器的时候会将sessionid一并发送给服务器。所以session机制依赖于cookie机制。

2.csrf攻击：cross site request forgery 跨站请求伪造
原理：
       1.User(C)访问信任网站Web(A)，Web(A)会在User(C)处设置A的cookie；
       2.User(C) 在没有登录A的情况下,访问危险网站Web(B),B要求User(C)访问Web(A);
       3.User(C)在Web(B)的要求下，带着Web(A)的cookie访问Web(A)，这样Web(B)就达到了模拟用户操作的目的

防御：
      1.通过 referer、token 或者 验证码 来检测用户提交。
      2.尽量不要在页面的链接中暴露用户隐私信息。
      3.对于用户修改删除等操作最好都使用post 操作 。
      4.避免全站通用的cookie，严格设置cookie的域
