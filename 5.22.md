**一、python的可变类型和不可变类型？**

不可变类型（数字、字符串、元组、不可变集合）
可变类型（列表、字典、可变集合）



**二、什么是装饰器？应用场景？**

装饰器的特点是返回值和参数都是函数

装饰器的目的就是对已封装函数进行操作，为其加上新的功能或一系列运算 。 在django中有middleware中间件，它其实就是高级的装饰器用法，

```python
def outside(func):    
    def inside(str):
        func(str)
        #函数体
    return inside  
@outside
def hello(str):
    #函数体
hello(str)
```



**三、一行代码实现9*9乘法表**

  print("\n".join("\t".join(["%s*%s=%s"%(x, y, x*y) **for** y **in** range(1, x + 1)])**for** x **in** range(1, 10)))



**四、new() 与 init()的区别**

- 1.首先用法不同
  - __new__()用于创建实例，所以该方法是在实例创建之前被调用，它是类级别的方法，是个静态方法；
  -  __init__() 用于初始化实例，所以该方法是在实例对象创建后被调用，它是实例级别的方法，用于设置对象属性的一些初始值。
  - 由此可知，__new__()在__init__() 之前被调用。如果__new__() 创建的是当前类的实例，会自动调用__init__()函数，通过return调用的__new__()的参数cls来保证是当前类实例，如果是其他类的类名，那么创建返回的是其他类实例，就不会调用当前类的__init__()函数。
- 2.其次传入参数不同
  - __new__()至少有一个参数cls，代表当前类，此参数在实例化时由Python解释器自动识别；
  - __init__()至少有一个参数self，就是这个__new__()返回的实例，__init__()在__new__()的基础上完成一些初始化的操作。
- 3.返回值不同
  - __new__()必须有返回值，返回实例对象；
  - __init__()不需要返回值。



**五、MySQL常见锁及出现死锁的原因**

- 常见的MYSQL锁有三种级别：**页级、表级、行级**
  - **表级锁**：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。
  - **行级锁**：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。
  - **页面锁**：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。
- **死锁的产生原因**
  - 所谓死锁: 是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去.此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等竺的进程称为死锁进程.表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB.

